{"version":3,"file":"TimeOrigin.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAoB,WAAID,IAExBD,EAAiB,WAAIC,GACtB,CATD,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,4BCWlF,MAAMI,EAA0B,CAC5BC,YAAa,IACbC,QAAS,IACTC,WAAY,EACZC,QAAQ,GAENC,EAAgB,CAAEC,UAAW,EAAGC,IAAK,EAAGC,UAAW,EAAGC,SAAU,GACvD,MAAMC,EACjBC,WAAAA,CAAYC,GAERC,KAAKC,aAAeT,EACpBQ,KAAKD,OAASZ,EACda,KAAKE,cAAe,EACpBF,KAAKG,cAAgB,EACrBH,KAAKI,YAAc,IACnBJ,KAAKK,aAAe,IACpBL,KAAKM,MAAQ,EACbN,KAAKD,OAASrB,OAAO6B,OAAO7B,OAAO6B,OAAO,CAAC,EAAGP,KAAKD,QAASA,EAChE,CACAS,KAAAA,GACIR,KAAKM,OAASG,aAAaT,KAAKM,OAChCN,KAAKC,aAAeT,EACpBQ,KAAKE,cAAe,EAEpBF,KAAKG,cAAgB,CACzB,CACAO,iBAAAA,GACI,OAtC8CC,EAsC7BX,KAtCsCY,OAsChC,EAtC+CC,EAsC/B,YAEnC,IAAKb,KAAKD,OAAOR,QACbS,KAAKE,cACLF,KAAKG,eAAiBH,KAAKD,OAAOT,WAClC,OAKJ,IAAIwB,EAJJd,KAAKE,cAAe,EACpBF,KAAKG,gBACLH,KAAKM,OAASG,aAAaT,KAAKM,OAChCN,KAAKM,MAAQ,EAEb,MAAMS,EAAKC,KAAKC,MAChB,IACIH,QClDLI,MAAM,uCAAuCC,MAAMC,GAAQA,EAAIC,QDmD9D,CACA,MAAOC,GAGH,OAFAC,QAAQC,KAAK,8CAA+CF,QAC5DtB,KAAKM,MAAQmB,WAAWzB,KAAK0B,gBAAgBC,KAAK3B,MAAOA,KAAKI,aAElE,CACA,MAAMV,EAAMsB,KAAKC,MAAQF,EACzBf,KAAK4B,MAAMd,EAAYpB,EAC3B,EA1DG,KAFgEmC,OAsCpC,KApCjBA,EAAIC,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKtB,EAAUuB,KAAKF,GAAS,CAAE,MAAOG,GAAKL,EAAOK,EAAI,CAAE,CAC1F,SAASC,EAASJ,GAAS,IAAMC,EAAKtB,EAAiB,MAAEqB,GAAS,CAAE,MAAOG,GAAKL,EAAOK,EAAI,CAAE,CAC7F,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBL,EAAIK,EAAQ,IAAIL,GAAE,SAAUE,GAAWA,EAAQG,EAAQ,KAIjBf,KAAKc,EAAWK,EAAW,CAC7GH,GAAMtB,EAAYA,EAAU4B,MAAM9B,EAASC,GAAc,KAAKwB,OAClE,IAPwC,IAAUzB,EAASC,EAAYiB,EAAGhB,CA6D1E,CACAe,KAAAA,CAAMd,EAAYpB,GACd,GAAIA,EAAMM,KAAKD,OAAOX,YAMlB,OAJAmC,QAAQC,KAAK,kEAAkE9B,UAE/EM,KAAKM,MAAQmB,WAAWzB,KAAKU,kBAAkBiB,KAAK3B,MAAOA,KAAKI,cAI3DV,EAAMM,KAAKD,OAAOV,SAGnBW,KAAKC,aAAaP,KAAOA,GAAOM,KAAKC,aAAaP,IAClD6B,QAAQmB,IAAI,qDAAqDhD,MAGjEM,KAAK0B,gBAAgBhC,EAAKoB,GAC1BS,QAAQmB,IAAI,iDAAiDhD,oBAAsBM,KAAKC,aAAaR,0BAA0BO,KAAKC,aAAaN,yBAAyBK,KAAKC,aAAaL,aAIhMI,KAAKM,MAAQmB,WAAWzB,KAAKU,kBAAkBiB,KAAK3B,MAAOA,KAAKI,aAE5DJ,KAAKG,cAAgB,IAAMH,KAAKD,OAAOT,aACvCU,KAAKG,cAAgB,KAKzBH,KAAK0B,gBAAgBhC,EAAKoB,GAE1BS,QAAQmB,IAAI,2BAA2BhD,oBAAsBM,KAAKC,aAAaR,0BAA0BO,KAAKC,aAAaN,yBAAyBK,KAAKC,aAAaL,YAEtKI,KAAKG,cAAgB,EACrBH,KAAKM,MAAQmB,WAAWzB,KAAKU,kBAAkBiB,KAAK3B,MAAOA,KAAKK,cAExE,CAiBAsC,UAAAA,CAAWC,GAIP,QAH+B,IAApBA,IACPA,EAAkB5C,KAAK6C,eAEvB7C,KAAK8C,kBAAkBF,GAAkB,CAEzC,MAAMG,EAAaC,KAAKC,MAAML,EAAgBM,KAAOlD,KAAKC,aAAaL,UACvE,OAAOI,KAAKC,aAAaR,UAAYsD,CACzC,CAGI,OAAO/B,KAAKC,KAEpB,CAaA6B,iBAAAA,CAAkBF,GACd,GAAI5C,KAAKC,aAAaR,UAAW,CAE7B,GAAoC,IAAhCO,KAAKC,aAAaN,UAClB,OAAO,EACX,MAAMwD,EAAoBP,EAAgBQ,MAAQpD,KAAKC,aAAaN,UAC9D0D,EAAyBT,EAAgBM,KAAOlD,KAAKC,aAAaL,SACxE,OAAOoD,KAAKM,IAAID,EAAyBF,GAAqB,GAClE,CAEA,OAAO,CACX,CAGA,uBAAOI,GAGH,QAA2B,oBAAhBC,cAAiCA,YAAYvC,IAG5D,CAIAS,eAAAA,CAAgBhC,EAAKoB,GACjBd,KAAKC,aAAe,CAChBR,UAAWqB,EAAakC,KAAKC,MAAMvD,EAAM,GACzCA,MACAC,UAAWE,EAAW0D,mBAAqBC,YAAYvC,MAAQ,EAC/DrB,SAAUoB,KAAKC,MAEvB,CASA4B,WAAAA,GACI,MAAO,CACHO,MAAOvD,EAAW0D,mBAAqBC,YAAYvC,MAAQ,EAC3DiC,KAAMlC,KAAKC,MAEnB,CACA,kBAAO4B,GACH,MAAO,CACHO,MAAOvD,EAAW0D,mBAAqBC,YAAYvC,MAAQ,EAC3DiC,KAAMlC,KAAKC,MAEnB,E","sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/webpack/runtime/define property getters","webpack://[name]/webpack/runtime/hasOwnProperty shorthand","webpack://[name]/./src/index.ts","webpack://[name]/./src/utils/request.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TimeOrigin\"] = factory();\n\telse\n\t\troot[\"TimeOrigin\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getServerTime } from \"./utils/request\";\nimport { platform } from \"./utils/platform\";\nconst defaultTimeOriginConfig = {\n    tolerantRTT: 3000,\n    bestRTT: 100,\n    maxChances: 5,\n    enable: true\n};\nconst defaultOrigin = { timestamp: 0, rtt: 0, baseClock: 0, baseTime: 0 };\nexport default class TimeOrigin {\n    constructor(config) {\n        // 服务端给的时间原点\n        this.serverOrigin = defaultOrigin;\n        this.config = defaultTimeOriginConfig;\n        this.isSettingNTP = false; // 是否正在计算 ntp 之中\n        this.currentChance = 0; // 当前是第几次请求这个 rtt 数量\n        this.failedDelay = 2000; // 原点设置失败后,定时 2s 再次尝试设置\n        this.successDelay = 5 * 60 * 1000; // 原点若是设置成功了, 定时 5 分钟再次设置\n        this.timer = 0; // 定时器\n        this.config = Object.assign(Object.assign({}, this.config), config);\n    }\n    reset() {\n        this.timer && clearTimeout(this.timer);\n        this.serverOrigin = defaultOrigin;\n        this.isSettingNTP = false;\n        // 重置当前尝试次数\n        this.currentChance = 0;\n    }\n    setOriginTimetick() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // 没有打开时间校准开关, 或者正在设置时间校准, 或者已经超过最大尝试次数，直接返回\n            if (!this.config.enable ||\n                this.isSettingNTP ||\n                this.currentChance >= this.config.maxChances)\n                return;\n            this.isSettingNTP = true;\n            this.currentChance++;\n            this.timer && clearTimeout(this.timer);\n            this.timer = 0;\n            let serverTime;\n            const t1 = Date.now();\n            try {\n                serverTime = yield getServerTime();\n            }\n            catch (error) {\n                console.warn(\"Calculate Delay time, getServerTime error: \", error);\n                this.timer = setTimeout(this.setServerOrigin.bind(this), this.failedDelay);\n                return;\n            }\n            const rtt = Date.now() - t1;\n            this.doSet(serverTime, rtt);\n        });\n    }\n    doSet(serverTime, rtt) {\n        if (rtt > this.config.tolerantRTT) {\n            /** 超出最大 rtt 容忍时间，此次计算作废 */\n            console.warn(`Denied, cause of exceeding the maximum tolerance range of RTT: ${rtt}`);\n            // 定时类似心跳的间隔再重新计算\n            this.timer = setTimeout(this.setOriginTimetick.bind(this), this.failedDelay);\n            ;\n            return;\n        }\n        else if (rtt > this.config.bestRTT) {\n            /** 在最大 rtt 容忍时间范围内，但大于最优的时间范围内 */\n            // 若新来的 rtt 的确比前面那次要更小，则更新. 反之则不更新\n            if (this.serverOrigin.rtt && rtt >= this.serverOrigin.rtt) {\n                console.log(`Denied, cause of current.RTT >= serverOrigin.RTT: ${rtt}`);\n            }\n            else {\n                this.setServerOrigin(rtt, serverTime);\n                console.log(`Accept within maximum tolerance range of RTT: ${rtt}, ntpTimestamp: ${this.serverOrigin.timestamp}, localClock: ${this.serverOrigin.baseClock}, localTime: ${this.serverOrigin.baseTime}`);\n            }\n            // 超过最佳 rtt 时间，但是尚且可以容忍, 再次计算他\n            // 定时类似心跳的间隔再重新计算\n            this.timer = setTimeout(this.setOriginTimetick.bind(this), this.failedDelay);\n            // 如果在最大 rtt 容忍时间范围内，但大于最优的时间范围，并且已经达到最大尝试次数，则尝试次数归 0。只有超出最大 rtt 容忍时间范围内，并且到达了最大尝试次数，才会停止请求服务器时间。\n            if (this.currentChance + 1 === this.config.maxChances) {\n                this.currentChance = 0;\n            }\n        }\n        else {\n            /** 在最优的时间范围内 */\n            this.setServerOrigin(rtt, serverTime);\n            // 达成最佳 rtt 时间, 则不再计算\n            console.log(`Accept within best RTT: ${rtt}, ntpTimestamp: ${this.serverOrigin.timestamp}, localClock: ${this.serverOrigin.baseClock}, localTime: ${this.serverOrigin.baseTime}`);\n            // 成功设置后, 尝试次数归 0\n            this.currentChance = 0;\n            this.timer = setTimeout(this.setOriginTimetick.bind(this), this.successDelay);\n        }\n    }\n    /**\n     * 获取端测可信的时间。若返回 0 则是一个不可相信的时间\n     *\n     *\n     * @param currentTimeNode 本地时间节点, 包含 performance.now 时刻以及 Date.now() 系统时间\n     *\n     *                           t2（服务器时间-响应的此刻时间戳）\n     *                          /  \\\n     *                         /    \\\n     *                        /      \\\n     * t1（端测时间-发起6-23协议） ------ t3（端测时间-接到回包）        ......(过了不知道多久)  t4\n     *\n     * t4 此刻真实时间 = t2 这个时刻, 即原点时刻的服务器时间(serverOrigin.timeStamp) + t2 到 t3 的差值 + t3 到 t4 的差值(也被称为 elapseTime)。\n     * t3 - t1 为 rtt 时间，代表发包与收包时间之差。t2 到 t3 的差值 ≈ 一半的 rtt。\n     * t3 到 t4 的差值(被称为 elapseTime) = t4 时刻的时间节点 - t3 时刻的时间节点，即为时间流逝值。\n     */\n    getNTPTime(currentTimeNode) {\n        if (typeof currentTimeNode === 'undefined') {\n            currentTimeNode = this.getTimeNode();\n        }\n        if (this.checkNodeReliable(currentTimeNode)) {\n            // 可信则计算时间\n            const elapseTime = Math.floor(currentTimeNode.time - this.serverOrigin.baseTime);\n            return this.serverOrigin.timestamp + elapseTime;\n        }\n        else {\n            // 输入了不可信的时间节点, 强行还要调用 getNTPTime 则直接返回当前系统时间吧\n            return Date.now();\n        }\n    }\n    /**\n     * 校验时间节点的偏移是否可信,\n     *\n     * 本地时钟的偏移量，和本地系统时间的偏移量的相对差值. 如果小于 500ms，就认为是可信的\n     * 如下图例子，偏移量 B 大于偏移量 A，那么可能是本地时间被用户修改了, 也可能是休眠了一段时间导致 performance.now() 流逝的比真实时间慢.\n     *\n     *       原点时刻   ....... 这个时刻\n     *       clock1            clock2\n     *         |      偏移量A     |\n     *         |      偏移量B     |\n     *       time1             time2\n     */\n    checkNodeReliable(currentTimeNode) {\n        if (this.serverOrigin.timestamp) {\n            // 不支持 performance.now() 的环境也只能采用系统时间, 当作可信吧\n            if (this.serverOrigin.baseClock === 0)\n                return true;\n            const differenceOfClock = currentTimeNode.clock - this.serverOrigin.baseClock;\n            const differenceOfClientTime = currentTimeNode.time - this.serverOrigin.baseTime;\n            return Math.abs(differenceOfClientTime - differenceOfClock) < 500;\n        }\n        // 未得到时间校验原点，当作不可信.\n        return false;\n    }\n    // 检查是否支持 performance.now()\n    // 鉴于微信小程序一读取 performance 就会抛出异常, 尚未知其他小程序以及 uniapp 的表现，故而目前在非浏览器都先判定为不支持\n    static checkPerformance() {\n        if (platform !== \"BROWSER\")\n            return false;\n        if (typeof performance !== \"undefined\" && !!performance.now)\n            return true;\n        return false;\n    }\n    /**\n     * 设置 NTP 时间基准点。\n     */\n    setServerOrigin(rtt, serverTime) {\n        this.serverOrigin = {\n            timestamp: serverTime + Math.floor(rtt / 2),\n            rtt,\n            baseClock: TimeOrigin.checkPerformance() ? performance.now() : 0,\n            baseTime: Date.now(),\n        };\n    }\n    /**\n     * 获取此刻的时间节点\n     *\n     * 包含 performance.now()，与 Date.now()\n     *\n     * performance.now() 的缺点是程序退入后台或者休眠后, 这个值会比实际的时间流逝值要小. 并且许多平台是不支持 performance 的\n     * Date.now() 的缺点是, 实例运行途中, 如果用户手动修改了系统时间, 没有手段能监测. 那么这个值就会不准确.\n     */\n    getTimeNode() {\n        return {\n            clock: TimeOrigin.checkPerformance() ? performance.now() : 0,\n            time: Date.now(),\n        };\n    }\n    static getTimeNode() {\n        return {\n            clock: TimeOrigin.checkPerformance() ? performance.now() : 0,\n            time: Date.now(),\n        };\n    }\n}\n","export const getServerTime = () => {\n    return fetch(\"http://127.0.0.1:3000/getServerTime\").then((res) => res.json());\n};\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","defaultTimeOriginConfig","tolerantRTT","bestRTT","maxChances","enable","defaultOrigin","timestamp","rtt","baseClock","baseTime","TimeOrigin","constructor","config","this","serverOrigin","isSettingNTP","currentChance","failedDelay","successDelay","timer","assign","reset","clearTimeout","setOriginTimetick","thisArg","_arguments","generator","serverTime","t1","Date","now","fetch","then","res","json","error","console","warn","setTimeout","setServerOrigin","bind","doSet","P","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","apply","log","getNTPTime","currentTimeNode","getTimeNode","checkNodeReliable","elapseTime","Math","floor","time","differenceOfClock","clock","differenceOfClientTime","abs","checkPerformance","performance"],"sourceRoot":""}