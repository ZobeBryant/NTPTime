!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.TimeOrigin=t():e.TimeOrigin=t()}(self,(function(){return(()=>{"use strict";var e={d:(t,i)=>{for(var r in i)e.o(i,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:i[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>s});const i={tolerantRTT:3e3,bestRTT:100,maxChances:5,enable:!0},r={timestamp:0,rtt:0,baseClock:0,baseTime:0};class s{constructor(e){this.serverOrigin=r,this.config=i,this.isSettingNTP=!1,this.currentChance=0,this.failedDelay=2e3,this.successDelay=3e5,this.timer=0,this.config=Object.assign(Object.assign({},this.config),e)}reset(){this.timer&&clearTimeout(this.timer),this.serverOrigin=r,this.isSettingNTP=!1,this.currentChance=0}setOriginTimetick(){return e=this,t=void 0,r=function*(){if(!this.config.enable||this.isSettingNTP||this.currentChance>=this.config.maxChances)return;let e;this.isSettingNTP=!0,this.currentChance++,this.timer&&clearTimeout(this.timer),this.timer=0;const t=Date.now();try{e=yield fetch("http://127.0.0.1:3000/getServerTime").then((e=>e.json()))}catch(e){return console.warn("Calculate Delay time, getServerTime error: ",e),void(this.timer=setTimeout(this.setServerOrigin.bind(this),this.failedDelay))}const i=Date.now()-t;this.doSet(e,i)},new((i=void 0)||(i=Promise))((function(s,n){function o(e){try{a(r.next(e))}catch(e){n(e)}}function c(e){try{a(r.throw(e))}catch(e){n(e)}}function a(e){var t;e.done?s(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(o,c)}a((r=r.apply(e,t||[])).next())}));var e,t,i,r}doSet(e,t){if(t>this.config.tolerantRTT)return console.warn(`Denied, cause of exceeding the maximum tolerance range of RTT: ${t}`),void(this.timer=setTimeout(this.setOriginTimetick.bind(this),this.failedDelay));t>this.config.bestRTT?(this.serverOrigin.rtt&&t>=this.serverOrigin.rtt?console.log(`Denied, cause of current.RTT >= serverOrigin.RTT: ${t}`):(this.setServerOrigin(t,e),console.log(`Accept within maximum tolerance range of RTT: ${t}, ntpTimestamp: ${this.serverOrigin.timestamp}, localClock: ${this.serverOrigin.baseClock}, localTime: ${this.serverOrigin.baseTime}`)),this.timer=setTimeout(this.setOriginTimetick.bind(this),this.failedDelay),this.currentChance+1===this.config.maxChances&&(this.currentChance=0)):(this.setServerOrigin(t,e),console.log(`Accept within best RTT: ${t}, ntpTimestamp: ${this.serverOrigin.timestamp}, localClock: ${this.serverOrigin.baseClock}, localTime: ${this.serverOrigin.baseTime}`),this.currentChance=0,this.timer=setTimeout(this.setOriginTimetick.bind(this),this.successDelay))}getNTPTime(e){if(void 0===e&&(e=this.getTimeNode()),this.checkNodeReliable(e)){const t=Math.floor(e.time-this.serverOrigin.baseTime);return this.serverOrigin.timestamp+t}return Date.now()}checkNodeReliable(e){if(this.serverOrigin.timestamp){if(0===this.serverOrigin.baseClock)return!0;const t=e.clock-this.serverOrigin.baseClock,i=e.time-this.serverOrigin.baseTime;return Math.abs(i-t)<500}return!1}static checkPerformance(){return!("undefined"==typeof performance||!performance.now)}setServerOrigin(e,t){this.serverOrigin={timestamp:t+Math.floor(e/2),rtt:e,baseClock:s.checkPerformance()?performance.now():0,baseTime:Date.now()}}getTimeNode(){return{clock:s.checkPerformance()?performance.now():0,time:Date.now()}}static getTimeNode(){return{clock:s.checkPerformance()?performance.now():0,time:Date.now()}}}return t.default})()}));
//# sourceMappingURL=TimeOrigin.js.map